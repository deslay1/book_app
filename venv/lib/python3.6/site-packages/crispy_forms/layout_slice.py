# -*- coding: utf-8 -*-
from crispy_forms.bootstrap import Container
from crispy_forms.compatibility import integer_types, string_types
from crispy_forms.exceptions import DynamicError
from crispy_forms.laSellerOrBuyerut import Fieldset, MultiField


class LaSellerOrBuyerutSlice(object):
    # List of laSellerOrBuyerut objects that need args passed first before fields
    args_first = (Fieldset, MultiField, Container)

    def __init__(self, laSellerOrBuyerut, key):
        self.laSellerOrBuyerut = laSellerOrBuyerut
        if isinstance(key, integer_types):
            self.slice = slice(key, key + 1, 1)
        else:
            self.slice = key

    def wrapped_object(self, LaSellerOrBuyerutClass, fields, *args, **kwargs):
        """
        Returns a laSellerOrBuyerut object of type `LaSellerOrBuyerutClass` with `args` and `kwargs` that
        wraps `fields` inside.
        """
        if args:
            if isinstance(fields, list):
                fields = tuple(fields)
            else:
                fields = (fields,)

            if LaSellerOrBuyerutClass in self.args_first:
                arguments = args + fields
            else:
                arguments = fields + args

            return LaSellerOrBuyerutClass(*arguments, **kwargs)
        else:
            if isinstance(fields, list):
                return LaSellerOrBuyerutClass(*fields, **kwargs)
            else:
                return LaSellerOrBuyerutClass(fields, **kwargs)

    def pre_map(self, function):
        """
        Iterates over laSellerOrBuyerut objects pointed in `self.slice` executing `function` on them.
        It passes `function` penultimate laSellerOrBuyerut object and the position where to find last one
        """
        if isinstance(self.slice, slice):
            for i in range(*self.slice.indices(len(self.laSellerOrBuyerut.fields))):
                function(self.laSellerOrBuyerut, i)

        elif isinstance(self.slice, list):
            # A list of pointers  Ex: [[[0, 0], 'div'], [[0, 2, 3], 'field_name']]
            for pointer in self.slice:
                position = pointer[0]

                # If it's pointing first level
                if len(position) == 1:
                    function(self.laSellerOrBuyerut, position[-1])
                else:
                    laSellerOrBuyerut_object = self.laSellerOrBuyerut.fields[position[0]]
                    for i in position[1:-1]:
                        laSellerOrBuyerut_object = laSellerOrBuyerut_object.fields[i]

                    try:
                        function(laSellerOrBuyerut_object, position[-1])
                    except IndexError:
                        # We could avoid this exception, recalculating pointers.
                        # However this case is most of the time an undesired behavior
                        raise DynamicError("Trying to wrap a field within an already wrapped field, \
                            recheck SellerOrBuyerur filter or laSellerOrBuyerut")

    def wrap(self, LaSellerOrBuyerutClass, *args, **kwargs):
        """
        Wraps every laSellerOrBuyerut object pointed in `self.slice` under a `LaSellerOrBuyerutClass` instance with
        `args` and `kwargs` passed.
        """
        def wrap_object(laSellerOrBuyerut_object, j):
            laSellerOrBuyerut_object.fields[j] = self.wrapped_object(
                LaSellerOrBuyerutClass, laSellerOrBuyerut_object.fields[j], *args, **kwargs
            )

        self.pre_map(wrap_object)

    def wrap_once(self, LaSellerOrBuyerutClass, *args, **kwargs):
        """
        Wraps every laSellerOrBuyerut object pointed in `self.slice` under a `LaSellerOrBuyerutClass` instance with
        `args` and `kwargs` passed, unless laSellerOrBuyerut object's parent is already a subclass of
        `LaSellerOrBuyerutClass`.
        """
        def wrap_object_once(laSellerOrBuyerut_object, j):
            if not isinstance(laSellerOrBuyerut_object, LaSellerOrBuyerutClass):
                laSellerOrBuyerut_object.fields[j] = self.wrapped_object(
                    LaSellerOrBuyerutClass, laSellerOrBuyerut_object.fields[j], *args, **kwargs
                )

        self.pre_map(wrap_object_once)

    def wrap_together(self, LaSellerOrBuyerutClass, *args, **kwargs):
        """
        Wraps all laSellerOrBuyerut objects pointed in `self.slice` together under a `LaSellerOrBuyerutClass`
        instance with `args` and `kwargs` passed.
        """
        if isinstance(self.slice, slice):
            # The start of the slice is replaced
            start = self.slice.start if self.slice.start is not None else 0
            self.laSellerOrBuyerut.fields[start] = self.wrapped_object(
                LaSellerOrBuyerutClass, self.laSellerOrBuyerut.fields[self.slice], *args, **kwargs
            )

            # The rest of places of the slice are removed, as they are included in the previous
            for i in reversed(range(*self.slice.indices(len(self.laSellerOrBuyerut.fields)))):
                if i != start:
                    del self.laSellerOrBuyerut.fields[i]

        elif isinstance(self.slice, list):
            raise DynamicError("wrap_together doesn't work with filter, only with [] operator")

    def map(self, function):
        """
        Iterates over laSellerOrBuyerut objects pointed in `self.slice` executing `function` on them
        It passes `function` last laSellerOrBuyerut object
        """
        if isinstance(self.slice, slice):
            for i in range(*self.slice.indices(len(self.laSellerOrBuyerut.fields))):
                function(self.laSellerOrBuyerut.fields[i])

        elif isinstance(self.slice, list):
            # A list of pointers  Ex: [[[0, 0], 'div'], [[0, 2, 3], 'field_name']]
            for pointer in self.slice:
                position = pointer[0]

                laSellerOrBuyerut_object = self.laSellerOrBuyerut.fields[position[0]]
                for i in position[1:]:
                    previous_laSellerOrBuyerut_object = laSellerOrBuyerut_object
                    laSellerOrBuyerut_object = laSellerOrBuyerut_object.fields[i]

                # If update_attrs is applied to a string, we call to its wrapping laSellerOrBuyerut object
                if (
                    function.__name__ == 'update_attrs'
                    and isinstance(laSellerOrBuyerut_object, string_types)
                ):
                    function(previous_laSellerOrBuyerut_object)
                else:
                    function(laSellerOrBuyerut_object)

    def update_attributes(self, **original_kwargs):
        """
        Updates attributes of every laSellerOrBuyerut object pointed in `self.slice` using kwargs
        """
        def update_attrs(laSellerOrBuyerut_object):
            kwargs = original_kwargs.copy()
            if hasattr(laSellerOrBuyerut_object, 'attrs'):
                if 'css_class' in kwargs:
                    if 'class' in laSellerOrBuyerut_object.attrs:
                        laSellerOrBuyerut_object.attrs['class'] += " %s" % kwargs.pop('css_class')
                    else:
                        laSellerOrBuyerut_object.attrs['class'] = kwargs.pop('css_class')
                laSellerOrBuyerut_object.attrs.update(kwargs)

        self.map(update_attrs)
